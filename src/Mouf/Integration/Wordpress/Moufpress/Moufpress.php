<?php

/*
 * This file is part of the Moufpress package.
 *
 * (c) 2014 David Negrier <david@mouf-php.com>
 *
 * For the full copyright and license information, please view the LICENSE.txt
 * file that was distributed with this source code.
 */

namespace Mouf\Integration\Wordpress\Moufpress;

use Mouf\Mvc\Splash\Services\SplashUtils;
use Mouf\MoufManager;
use Mouf\Mvc\Splash\Services\UrlProviderInterface;
use Mouf\Mvc\Splash\Services\SplashRequestContext;
use Mouf\Mvc\Splash\Utils\SplashException;
use Mouf\Utils\Cache\CacheInterface;
use Mouf\Mvc\Splash\HtmlResponse;
use Mouf\Html\Utils\WebLibraryManager\WebLibraryInterface;
use Zend\Diactoros\ServerRequestFactory;

/**
 * This class is the root class of Moufpress. It is in charge of mapping Splash MVC controllers to the
 * Wordpress routing system.
 *
 * @author David NÃ©grier <d.negrier@thecodingmachine.com>
 */
class Moufpress
{
    /**
     * A pointer to the wordpressTemplate.
     *
     * @var WordpressTemplate
     */
    private $wordpressTemplate;

    /**
     * The cache service that will be used to store routes.
     *
     * @var CacheInterface
     */
    private $cacheService;

    /**
     * A map associating the Wordpress name of a enqueued script/style with the WebLibrary that replaces it.
     * This is useful because there are special use cases where a WebLibrary overrides an existing
     * library managed by Wordpress.
     *
     * @var array<string, WebLibraryInterface>
     */
    private $replacedWebLibrary;

    /**
     * A map of WebLibraryInterface=>name.
     *
     * @var \SplObjectStorage
     */
    private $webLibraryNames;

    /**
     * List of objects that provide routes.
     *
     * @var UrlProviderInterface[]
     */
    private $routeProviders = [];

    private $initDone = false;

    /**
     * @param UrlProviderInterface[]             $routeProviders     List of objects that provide routes.
     * @param WordpressTemplate                  $wordpressTemplate  A pointer to the wordpressTemplate.
     * @param CacheInterface                     $cacheService       The cache service that will be used to store routes.
     * @param array<string, WebLibraryInterface> $replacedWebLibrary
     */
    public function __construct(array $routeProviders, WordpressTemplate $wordpressTemplate, CacheInterface $cacheService = null, $replacedWebLibrary = array())
    {
        $this->routeProviders = $routeProviders;
        $this->wordpressTemplate = $wordpressTemplate;
        $this->cacheService = $cacheService;

        $this->replacedWebLibrary = $replacedWebLibrary;

        // Let's load the list of replaced web libraries.
        $this->webLibraryNames = new \SplObjectStorage();

        add_action('wp_router_generate_routes', array($this, 'generate_routes'), 10, 1);

        add_action('widgets_init', function () {
            register_widget('Mouf\\Integration\\Wordpress\\Moufpress\\MoufpressWidget');
        });
    }

    private function init()
    {
        if ($this->initDone) {
            return;
        }
        $this->initDone = true;

        $webLibraryNames = $this->webLibraryNames;
        array_walk($this->replacedWebLibrary, function (WebLibraryInterface $webLibrary, $name) use ($webLibraryNames) {
            // Let's replace all the libs declared in Wordpress with our libs instead.
            $this->registerWordpressLib($webLibrary, $name);
        });
        $this->webLibraryNames = $webLibraryNames;
    }

    /**
     * Registers a weblibrary in Wordpress (using wp_register_script and wp_register_style).
     * Uses $name is the name of passed. Otherwise, the name is autogenerated.
     *
     * @param WebLibraryInterface $webLibrary
     * @param string              $name
     *
     * @return string The Wordpress name for the Weblibrary.
     */
    public function registerWordpressLib(WebLibraryInterface $webLibrary, $name = null)
    {
        $this->init();

        if ($this->webLibraryNames->contains($webLibrary)) {
            return $this->webLibraryNames[$webLibrary];
        }

        if ($name == null) {
            $name = 'moufpress_'.self::$count;
            ++self::$count;
        }
        $this->webLibraryNames->attach($webLibrary, $name);

        $files = $webLibrary->getJsFiles();

        // We must map each file to one script in Wordpress.
        // We must add dependencies between these files.
        $lastDependencyName = null;
        $cnt = 0;

        $rootUrl = get_bloginfo('url');

        foreach ($files as $file) {
            // If this is the last:
            if ($cnt == count($files) - 1) {
                $wpName = $name;
            } else {
                $wpName = $name.'_'.$cnt;
            }
            $dependencies = [];
            if ($lastDependencyName) {
                $dependencies[] = $lastDependencyName;
            }

            if (wp_script_is($wpName, 'registered')) {
                wp_deregister_script($wpName);
            }

            if (strpos($file, 'http://') === false && strpos($file, 'https://') === false && strpos($file, '/') !== 0) {
                wp_register_script($wpName, $rootUrl.'/'.$file, $dependencies);
            } else {
                wp_register_script($wpName, $file, $dependencies);
            }

            $lastDependencyName = $wpName;
            ++$cnt;
        }

        // Same thing for CSS:
        $files = $webLibrary->getCssFiles();

        // We must map each file to one script in Wordpress.
        // We must add dependencies between these files.
        $lastDependencyName = null;
        $cnt = 0;

        foreach ($files as $file) {
            // If this is the last:
            if ($cnt == count($files) - 1) {
                $wpName = $name;
            } else {
                $wpName = $name.'_'.$cnt;
            }
            $dependencies = [];
            if ($lastDependencyName) {
                $dependencies[] = $lastDependencyName;
            }

            if (wp_style_is($wpName, 'registered')) {
                wp_deregister_style($wpName);
            }

            if (strpos($file, 'http://') === false && strpos($file, 'https://') === false && strpos($file, '/') !== 0) {
                wp_register_style($wpName, $rootUrl.'/'.$file, $dependencies);
            } else {
                wp_register_style($wpName, $file, $dependencies);
            }

            $lastDependencyName = $wpName;
            ++$cnt;
        }

        return $name;
    }

    public function generate_routes($router)
    {
        /* @var $router \WP_Router */
        $routes = $this->getRoutesWithCache();
        foreach ($routes as $i => $route) {
            $router->add_route('moufpress_route_'.$i, $route);
        }
    }

    /**
     * Returns the list of routes as an array of arrays.
     * Uses the cache mechanism if available.
     *
     * @throws SplashException
     *
     * @return array<array>
     */
    public function getRoutesWithCache()
    {
        if ($this->cacheService == null) {
            // Retrieve the split parts
            return $this->getRoutesWithoutCache();
        } else {
            $routes = $this->cacheService->get('splashWordpressRoutes');
            if ($routes == null) {
                // No value in cache, let's get the URL nodes
                $routes = $this->getRoutesWithoutCache();
                $this->cacheService->set('splashWordpressRoutes', $routes);
            }

            return $routes;
        }
    }

    /**
     * Returns the list of routes as an array of arrays.
     * Bypasses the cache mechanism.
     *
     * @throws SplashException
     *
     * @return array<array>
     */
    public function getRoutesWithoutCache()
    {
        $urlsList = array();

        foreach ($this->routeProviders as $routeProvider) {
            /* @var $routeProvider UrlProviderInterface */
            $tmpUrlList = $routeProvider->getUrlsList(null);
            $urlsList = array_merge($urlsList, $tmpUrlList);
        }

        $items = array();

        foreach ($urlsList as $urlCallback) {
            /* @var $urlCallback SplashCallback */

            $url = $urlCallback->url;
            // remove trailing slash
            $url = rtrim($url, '/');

            $title = null;
            if ($urlCallback->title !== null) {
                $title = $urlCallback->title;
            }

            //////////////// Let's analyze the URL for parameter ////////////////////
            $trimmedUrl = trim($url, '/');
            $urlParts = explode('/', $trimmedUrl);
            $urlPartsNew = array();
            $parametersList = array();
                        // We will store the number of parameters for a URL
                        $nbParam = 0;

            for ($i = 0; $i < count($urlParts); ++$i) {
                $urlPart = $urlParts[$i];
                if (strpos($urlPart, '{') === 0 && strpos($urlPart, '}') === strlen($urlPart) - 1) {
                    $nbParam += 1;
                    // Parameterized URL element
                    $varName = substr($urlPart, 1, strlen($urlPart) - 2);

                    $parametersList[$varName] = $i;
                    $urlPartsNew[] = '([^/]*?)';
                } else {
                    $urlPartsNew[] = $urlPart;
                }
            }

            // Let's rewrite the URL, but replacing the {var} parameters with a regexp wildcard
            $url = '^'.implode('/', $urlPartsNew).'$';
            ///////////////// End URL analysis ////////////////////

            $httpMethods = $urlCallback->httpMethods;
            if (empty($httpMethods)) {
                $httpMethods['default'] = 'moufpress_execute_action';
            } else {
                foreach ($httpMethods as $httpMethod) {
                    $httpMethods[strtoupper($httpMethod)] = 'moufpress_execute_action';
                }
            }

            foreach ($httpMethods as $httpMethod) {
                $item = array(
                        'path' => $url,

                        'page_callback' => $httpMethods,
                        // First argument passed to execute_action as the instance name, second argument is the method.
                        'page_arguments' => array($urlCallback->controllerInstanceName, $urlCallback->methodName, $parametersList, $urlCallback->parameters, $urlCallback->filters),
                        'access_callback' => true,
                                                 // We store the number of parameters for an item
                                                'nbParam' => $nbParam,
                        //'page arguments' => array(array($httpMethod => array("instance"=>$urlCallback->controllerInstanceName, "method"=>$urlCallback->methodName, "urlParameters"=>$parametersList))),
                );

                if ($title) {
                    $item['title'] = $title;
                }

                $items[] = $item;
            }
        }

                /*
                 * We sort the tableOfURLS with the one with the fewer parameters coming first
                 */
                usort($items, function (array $a, array $b) {
                    return $a['nbParam'] - $b['nbParam'];
                });

        return $items;
    }

    public function executeAction($instanceName, $method, $urlParameters, $parameters, $filters)
    {
        $request = ServerRequestFactory::fromGlobals(
            $_SERVER,
            $_GET,
            $_POST,
            $_COOKIE,
            $_FILES
        );

        $controller = MoufManager::getMoufManager()->get($instanceName);

        if (method_exists($controller, $method)) {
            $requestParts = array();
            if ($urlParameters) {
                $pathinfo = isset($_SERVER['PATH_INFO']) ? $_SERVER['PATH_INFO'] : '';
                list($pathinfo) = explode('?', $pathinfo);
                $pathinfo = str_replace('%', '%25', $pathinfo);
                list($req_uri) = explode('?', $_SERVER['REQUEST_URI']);
                $home_path = trim(parse_url(home_url(), PHP_URL_PATH), '/');

                // Trim path info from the end and the leading home path from the
                // front.
                $req_uri = str_replace($pathinfo, '', $req_uri);
                $req_uri = trim($req_uri, '/');
                $req_uri = preg_replace("|^$home_path|i", '', $req_uri);
                $req_uri = trim($req_uri, '/');
                $requestParts = explode('/', $req_uri);
            }

            $context = new SplashRequestContext($request);
            $context->setUrlParameters(array_map(function ($itemPos) use ($requestParts) { return $requestParts[$itemPos]; }, $urlParameters));

            /****/
            $args = array();
            foreach ($parameters as $paramFetcher) {
                /* @var $param SplashParameterFetcherInterface */
                $args[] = $paramFetcher->fetchValue($context);
            }

            // Handle action__GET or action__POST method (for legacy code).
            if (method_exists($controller, $method.'__'.$_SERVER['REQUEST_METHOD'])) {
                $method = $method.'__'.$_SERVER['REQUEST_METHOD'];
            }

            // Apply filters
            for ($i = count($filters) - 1; $i >= 0; --$i) {
                $filters[$i]->beforeAction();
            }

            header_remove('Expires');
            header_remove('Cache-Control');
            header_remove('Pragma');

            $response = SplashUtils::buildControllerResponse(
                    function () use ($controller, $method, $args) {
                        return call_user_func_array(array($controller, $method), $args);
                    }
            );

            $wordpressTemplate = $this->wordpressTemplate;

            ob_start();
            if ($response instanceof HtmlResponse) {
                $htmlElement = $response->getHtmlElement();
                if ($htmlElement instanceof WordpressTemplate) {
                    $htmlElement->toHtml();
                    $htmlElement->getWebLibraryManager()->toHtml();
                    $htmlElement->getContentBlock()->toHtml();
                } else {
                    $response->send();
                }
            } else {
                $response->sendHeaders();
                $response->sendContent();
                if ($wordpressTemplate->isDisplayTriggered()) {
                    $wordpressTemplate->getWebLibraryManager()->toHtml();
                    $wordpressTemplate->getContentBlock()->toHtml();
                }
            }
            $result = ob_get_clean();

            if ($wordpressTemplate->isDisplayTriggered()) {
                $title = $wordpressTemplate->getTitle();
                if ($title) {
                    $posts = get_posts(array(
                            'post_type' => \WP_Router_Page::POST_TYPE,
                            'post_status' => 'publish',
                            'posts_per_page' => 1,
                    ));
                    if ($posts) {
                        $page_post_id = $posts[0]->ID;
                    } else {
                        $page_post_id = null;
                    }

                    add_filter('the_title', function ($previousTitle, $postId = null) use ($title, $page_post_id) {
                        if (in_the_loop() || $page_post_id == $postId) {
                            return $title;
                        }

                        return $previousTitle;
                    }, 11);
                    add_filter('wp_title', function () use ($title) {
                        return $title;
                    }, 11);
                }
            }

            foreach ($filters as $filter) {
                $filter->afterAction();
            }

            // Now, let's see if we must output everything in the template or out the template.

            if ($wordpressTemplate->isDisplayTriggered()) {
                echo $result;
            } else {
                echo $result;
                exit;
            }
        } else {
            global $wp_query;
            $wp_query->set_404();
        }
    }
}
